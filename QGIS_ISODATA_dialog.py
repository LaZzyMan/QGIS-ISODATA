# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QGIS_ISODATADialog
                                 A QGIS plugin
 An ISODATA plugin for QGIS.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2018-06-06
        git sha              : $Format:%H$
        copyright            : (C) 2018 by LaZzy
        email                : 924797163@qq.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import re
from PyQt5.QtCore import pyqtSlot, Qt
from PyQt5.QtWidgets import QMainWindow, QMessageBox, QProgressDialog, QColorDialog, QFileDialog
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPixmap, QColor
from numpy import *
from numba import jit
import matplotlib.image as image
from scipy import misc
if __name__ == '__main__':
    from Ui_ISODATA import Ui_ISODATA
else:
    from .Ui_ISODATA import Ui_ISODATA


@jit(nopython=True)
def distance(l1, l2):
    d = 0
    l = l1 - l2
    for x in l:
        d = d + x**2
    return sqrt(d)

def findArray(A, arr):
    for i, a in zip(range(len(A)), A):
        if (a == arr).all():
            return i
    return -1


class ISODATA(QMainWindow, Ui_ISODATA):
    """
    Class documentation goes here.
    """

    def __init__(self, parent=None):
        """
        Constructor

        @param parent reference to the parent widget
        @type QWidget
        """
        super(ISODATA, self).__init__(parent)
        self.setupUi(self)
        self.numOfPicture = 0
        self.img = []
        self.colorMap = {0: [176, 224, 230], 1: [255, 255, 0], 2: [255, 255, 255], 3: [65, 105, 225], 4: [0, 255, 0],
                         5: [176, 23, 31], 6: [255, 69, 0], 7: [41, 36, 33], 8: [160, 102, 211], 9: [135, 51, 36]}
        for i in range(10, 50):
            self.colorMap[i] = [random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)]

        with open(os.path.join(os.path.dirname(__file__), 'style.qss')) as qss:
            self.setStyleSheet(qss.read())

    def ISODATA(self):
        # 建立特征值字典
        img = {}
        for i in range(self.width):
            for j in range(self.height):
                img[(i, j)] = array(
                    [self.img[0][i, j], self.img[1][i, j], self.img[2][i, j], self.img[3][i, j], self.img[4][i, j],
                     self.img[5][i, j]], dtype=int)
        del self.img

        C = 5
        M = 0.5
        # 随机生成初始中心点
        Z = [img[(0, s)] for s in range(C)]
        iteration = 0
        self.progressBar.setMaximum(self.I)
        self.progressBar.setValue(iteration)
        self.label_progress.setText('正在进行第 ' + str(iteration) + ' / ' + str(self.I) + ' 次迭代...')

        while 1:
            iteration += 1
            self.label_progress.setText('正在进行第 ' + str(iteration) + ' / ' + str(self.I) + ' 次迭代...')
            self.progressBar.setValue(iteration)
            # 求各点到聚类中心的距离
            f = [[] for i in range(len(Z))]
            for i in range(self.width):
                for j in range(self.height):
                    D = [distance(img[(i, j)], z) for z in Z]
                    f[D.index(min(D))].append((i, j))

            # 删除样本数少于最小样本数的类别
            def thetaNFilter(x):
                if len(x[0]) < self.thetaN:
                    return False
                else:
                    return True

            newlist = list(filter(thetaNFilter, [(ff, zz) for ff, zz in zip(f, Z)]))
            f = [x[0] for x in newlist]
            Z = [x[1] for x in newlist]

            # 计算新的聚类中心
            Z_temp = []
            for i in range(len(Z)):
                z = array([0 for i in range(self.numOfPicture)])
                for x in f[i]:
                    z = z + img[x]
                Z_temp.append(z / len(f[i]))
            Z = [i for i in Z_temp]

            # 判断是否是最后一次迭代
            if iteration == self.I:
                return f

            # 计算各聚类样本到聚类中心距离的平均值
            dj = array([0.0 for ff in f])
            for i, fj, zj in zip(range(len(Z)), f, Z):
                for fij in fj:
                    dj[i] += distance(img[fij], zj)
                dj[i] = dj[i] / len(fj)

            # 计算所有样本到相应聚类中心的距离平均值
            d_avg = sum(dj * array([len(i) for i in f])) / sum([len(i) for i in f])

            # 分裂操作
            time_of_division = 0
            if len(Z) < 2 * self.K and iteration % 2 == 1:
                # 计算每一类别样本与聚类中心距离标准差
                theta_S = []
                for fj, zj in zip(f, Z):
                    tan_f = [img[fij] for fij in fj]
                    thetaj = array([0 for i in range(self.numOfPicture)])
                    for fi in tan_f:
                        thetaj = thetaj + (fi - zj) ** 2
                    thetaj = sqrt(thetaj / (len(fj)))
                    theta_S.append([max(thetaj), thetaj.tolist().index(max(thetaj))])

                for fj, zj, thetajmax, j in zip(f, Z_temp, theta_S, range(len(Z_temp))):
                    if thetajmax[0] > self.thetaS:
                        if len(Z_temp) <= int(self.K / 2):
                            zj1 = array([i for i in zj])
                            zj2 = array([i for i in zj])
                            zj1[thetajmax[1]] = zj[thetajmax[1]] + thetajmax[0] * M
                            zj2[thetajmax[1]] = zj[thetajmax[1]] - thetajmax[0] * M
                            Z.pop(findArray(Z, Z_temp[j]))
                            Z.append(zj1)
                            Z.append(zj2)
                            time_of_division += 1
                            continue
                        if dj[j] > d_avg and len(f[j]) > 2 * (self.thetaN + 1):
                            zj1 = array([i for i in zj])
                            zj2 = array([i for i in zj])
                            zj1[thetajmax[1]] = zj[thetajmax[1]] + thetajmax[0] * M
                            zj2[thetajmax[1]] = zj[thetajmax[1]] - thetajmax[0] * M
                            Z.pop(findArray(Z, Z_temp[j]))
                            Z.append(zj1)
                            Z.append(zj2)
                            time_of_division += 1
                            continue
            # 分裂结束，进入下一次迭代
            if time_of_division != 0:
                continue

            # 合并操作
            d_z = {}
            for i in range(len(Z)):
                for j in range(len(Z)):
                    if i == j: continue
                    if distance(Z[i], Z[j]) < self.thetaC:
                        d_z[(i, j)] = distance(Z[i], Z[j])
            zNear = [i[0] for i in sorted(d_z.items(), key=lambda d: d[1])]
            combined = []
            for zz in zNear:
                if zz[0] not in combined and zz[1] not in combined:
                    z_double = (len(f[zz[0]]) * Z_temp[zz[0]] + len(f[zz[1]]) * Z_temp[zz[1]]) / (
                            len(f[zz[0]]) + len(f[zz[1]]))
                    Z.pop(findArray(Z, Z_temp[zz[0]]))
                    Z.pop(findArray(Z, Z_temp[zz[1]]))
                    Z.append(z_double)
                    combined.append(zz[0])
                    combined.append(zz[1])

    @pyqtSlot()
    def on_pushButton_cancel_clicked(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        self.lineEdit_K.clear()
        self.lineEdit_L.clear()
        self.lineEdit_I.clear()
        self.lineEdit_thetaS.clear()
        self.lineEdit_thetaC.clear()
        self.lineEdit_thetaN.clear()
        self.label_IMG.setText("                              运算结果图像")
        self.pushButton_iteration.setEnabled(False)
        self.pushButton_iterationnForOnce.setEnabled(False)
        self.pushButton_save.setEnabled(False)
        self.label_progress.setText('准备就绪')
        self.progressBar.setValue(0)
        del self.colorblocks
        self.groupBox_color.setEnabled(False)
        self.pushButton_changeColor.setEnabled(False)

    @pyqtSlot()
    def on_pushButton_iterationnForOnce_clicked(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        self.K = 10
        self.L = 10
        self.I = 10
        self.thetaC = 10
        self.thetaN = 1000
        self.thetaS = 14
        self.lineEdit_K.setText('10')
        self.lineEdit_I.setText('10')
        self.lineEdit_thetaN.setText('1000')
        self.lineEdit_L.setText('10')
        self.lineEdit_thetaC.setText('10')
        self.lineEdit_thetaS.setText('14')
        self.pushButton_iteration.setEnabled(True)
        self.pushButton_cancel.setEnabled(True)

    @pyqtSlot()
    def on_pushButton_iteration_clicked(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        if len(self.img) == 0:
            QMessageBox.information(self, 'Error', '未读入任何图像')
            return
        self.f = self.ISODATA()
        if self.f == None:
            return
        self.result = ones((self.width, self.height, 3), dtype=uint8)

        # 生成和显示色斑图
        for i in range(len(self.f)):
            for fij in self.f[i]:
                self.result[fij[0], fij[1]] = self.colorMap[i]
        self.pushButton_changeColor.setEnabled(True)

        misc.imsave('temp.png', self.result)
        self.label_IMG.setPixmap(QPixmap('temp.png'))
        self.label_progress.setText('完成！')
        os.remove('temp.png')
        self.pushButton_save.setEnabled(True)
        return

    @pyqtSlot()
    def on_pushButton_changeParaments_clicked(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        if self.lineEdit_K.text() != '':
            self.K = int(self.lineEdit_K.text())
        else:
            QMessageBox.information(self, 'Error', '参数不能为空')
            return
        if self.lineEdit_thetaN.text() != '':
            self.thetaN = int(self.lineEdit_thetaN.text())
        else:
            QMessageBox.information(self, 'Error', '参数不能为空')
            return
        if self.lineEdit_thetaC.text() != '':
            self.thetaC = int(self.lineEdit_thetaC.text())
        else:
            QMessageBox.information(self, 'Error', '参数不能为空')
            return
        if self.lineEdit_thetaS.text() != '':
            self.thetaS = int(self.lineEdit_thetaS.text())
        else:
            QMessageBox.information(self, 'Error', '参数不能为空')
            return
        if self.lineEdit_I.text() != '':
            self.I = int(self.lineEdit_I.text())
        else:
            QMessageBox.information(self, 'Error', '参数不能为空')
            return
        if self.lineEdit_L.text() != '':
            self.L = int(self.lineEdit_L.text())
        else:
            QMessageBox.information(self, 'Error', '参数不能为空')
            return
        self.pushButton_iteration.setEnabled(True)
        self.pushButton_cancel.setEnabled(True)

    @pyqtSlot()
    def on_pushButton_save_clicked(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        if self.result == None:
            QMessageBox.information(self, 'Error', '没有可保存图像')
            return
        filename = QFileDialog.getSaveFileName(self, '保存文件', filter='Image Files(*.png *.jpg *.bmp *.TIF)')
        misc.imsave(filename[0], self.result)

    @pyqtSlot()
    def on_pushButton_changeColor_clicked(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        self.groupBox_color.setEnabled(True)
        gridLayout_color = QtWidgets.QHBoxLayout(self.groupBox_color)
        gridLayout_color.setObjectName("gridLayout_color")
        self.colorblocks = {}
        for i in range(len(self.f)):
            self.colorblocks[i] = QtWidgets.QPushButton(self.groupBox_color)
            self.colorblocks[i].setStyleSheet(
                'QPushButton{background-color:%s}' % QColor(self.colorMap[i][0], self.colorMap[i][1],
                                                            self.colorMap[i][2]).name())
            self.colorblocks[i].setObjectName('colorblock' + str(i))
            self.colorblocks[i].clicked.connect(self.on_colorblock_clicked)
            gridLayout_color.addWidget(self.colorblocks[i])

    @pyqtSlot()
    def on_pushButton_remove_clicked(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        target = self.listWidget_IMG.currentRow()
        self.listWidget_IMG.takeItem(target)
        self.img.pop(target)
        self.tabWidget.removeTab(target)
        self.numOfPicture -= 1
        self.label_progress.setText('准备就绪')
        self.progressBar.setValue(0)

    @pyqtSlot()
    def on_pushButton_display_clicked(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        for target in range(len(self.img)):
            self.listWidget_IMG.takeItem(0)
            self.img.pop(0)
            self.tabWidget.removeTab(0)
        self.numOfPicture = 0

    def on_colorblock_clicked(self):
        color = QColorDialog(self).getColor()
        button = self.groupBox_color.sender()
        m = re.match(r'(\w+)(\d+)', button.objectName())
        target = int(m.group(2))
        self.colorMap[target] = [color.red(), color.green(), color.blue()]
        self.colorblocks[target].setStyleSheet('QPushButton{background-color:%s}' % color.name())
        for fij in self.f[target]:
            self.result[fij[0], fij[1]] = self.colorMap[target]
        misc.imsave('temp.png', self.result)
        self.label_IMG.setPixmap(QPixmap('temp.png'))
        self.label_progress.setText('完成！')
        os.remove('temp.png')

    @pyqtSlot()
    def on_pushButton_add_clicked(self):
        """
        Slot documentation goes here.
        """
        # TODO: not implemented yet
        filenames = QFileDialog(self).getOpenFileNames(self, '打开图像文件', filter='Image Files(*.png *.jpg *.bmp *.TIF)')
        for filename in filenames[0]:
            self.numOfPicture += 1
            f = image.imread(filename)
            self.width = len(f)
            self.height = len(f[0])
            self.listWidget_IMG.addItem(filename)
            self.img.append(f)

            tab = QtWidgets.QWidget()
            tab.setObjectName("tab")
            gridLayout_6 = QtWidgets.QGridLayout(tab)
            gridLayout_6.setContentsMargins(0, 0, 0, 0)
            gridLayout_6.setObjectName("gridLayout_6")
            scrollArea_2 = QtWidgets.QScrollArea(tab)
            scrollArea_2.setWidgetResizable(True)
            scrollArea_2.setObjectName("scrollArea_2")
            scrollAreaWidgetContents_2 = QtWidgets.QWidget()
            scrollAreaWidgetContents_2.setGeometry(QtCore.QRect(0, 0, 570, 548))
            scrollAreaWidgetContents_2.setObjectName("scrollAreaWidgetContents_2")
            gridLayout_5 = QtWidgets.QGridLayout(scrollAreaWidgetContents_2)
            gridLayout_5.setContentsMargins(0, 0, 0, 0)
            gridLayout_5.setObjectName("gridLayout_5")
            label_Result = QtWidgets.QLabel(scrollAreaWidgetContents_2)
            label_Result.setObjectName("label_Result")
            gridLayout_5.addWidget(label_Result, 0, 1, 1, 1)
            scrollArea_2.setWidget(scrollAreaWidgetContents_2)
            gridLayout_6.addWidget(scrollArea_2, 0, 0, 1, 1)
            self.tabWidget.addTab(tab, "")
            self.tabWidget.setTabText(self.tabWidget.indexOf(tab), '图层' + str(self.numOfPicture))
            label_Result.setPixmap(QPixmap(filename))


class QGIS_ISODATADialog(QtWidgets.QDialog, Ui_ISODATA):
    def __init__(self, parent=None):
        """Constructor."""
        super(QGIS_ISODATADialog, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)


if __name__ == '__main__':
    import sys
    from PyQt5.QtWidgets import QApplication
    app = QApplication(sys.argv)
    dlg = ISODATA()
    dlg.show()
    sys.exit(app.exec_())
